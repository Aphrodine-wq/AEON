-- AEON Example: Data Structures with Formal Contracts
-- Demonstrates: separation logic, ownership, pointer safety, linked list invariants
--
-- AEON verifies:
--   1. Stack push/pop maintain size invariant
--   2. Queue enqueue/dequeue maintain FIFO ordering contract
--   3. Linked list operations preserve structural integrity
--   4. No use-after-free via ownership tracking

-- -----------------------------------------------------------------------
-- Stack — array-backed with bounds contracts
-- -----------------------------------------------------------------------

data Stack {
  items: List<Int>
  size:  Int
}

pure stackNew() -> Stack {
  ensures: result.size == 0
  return Stack { items: [], size: 0 }
}

pure stackPush(s: Stack, value: Int) -> Stack {
  requires: s.size >= 0
  ensures:  result.size == s.size + 1
  return Stack { items: s.items, size: s.size + 1 }
}

pure stackPop(s: Stack) -> Stack {
  requires: s.size > 0
  ensures:  result.size == s.size - 1
  -- AEON verifies: requires s.size > 0 prevents underflow
  -- The ownership system ensures 's' is not used after pop
  return Stack { items: s.items, size: s.size - 1 }
}

pure stackPeek(s: Stack) -> Int {
  requires: s.size > 0
  -- AEON verifies: non-empty precondition prevents out-of-bounds access
  return s.items.get(s.size - 1)
}

pure stackIsEmpty(s: Stack) -> Bool {
  ensures: result == (s.size == 0)
  return s.size == 0
}

-- -----------------------------------------------------------------------
-- Bounded counter — overflow-safe arithmetic
-- -----------------------------------------------------------------------

data Counter {
  value: Int
  max:   Int
}

pure counterNew(max: Int) -> Counter {
  requires: max > 0
  ensures:  result.value == 0
  ensures:  result.max == max
  return Counter { value: 0, max: max }
}

pure counterIncrement(c: Counter) -> Counter {
  requires: c.value < c.max
  ensures:  result.value == c.value + 1
  ensures:  result.max == c.max
  -- AEON verifies: value never exceeds max (overflow-safe)
  return Counter { value: c.value + 1, max: c.max }
}

pure counterDecrement(c: Counter) -> Counter {
  requires: c.value > 0
  ensures:  result.value == c.value - 1
  ensures:  result.max == c.max
  -- AEON verifies: value never goes below 0 (underflow-safe)
  return Counter { value: c.value - 1, max: c.max }
}

pure counterReset(c: Counter) -> Counter {
  ensures: result.value == 0
  ensures: result.max == c.max
  return Counter { value: 0, max: c.max }
}

-- -----------------------------------------------------------------------
-- Range — interval arithmetic with invariant preservation
-- -----------------------------------------------------------------------

data Range {
  lo: Int
  hi: Int
}

pure rangeNew(lo: Int, hi: Int) -> Range {
  requires: lo <= hi
  ensures:  result.lo == lo
  ensures:  result.hi == hi
  return Range { lo: lo, hi: hi }
}

pure rangeContains(r: Range, x: Int) -> Bool {
  requires: r.lo <= r.hi
  ensures:  result == (x >= r.lo && x <= r.hi)
  return x >= r.lo && x <= r.hi
}

pure rangeSize(r: Range) -> Int {
  requires: r.lo <= r.hi
  ensures:  result >= 0
  ensures:  result == r.hi - r.lo + 1
  return r.hi - r.lo + 1
}

pure rangeIntersect(a: Range, b: Range) -> Range {
  requires: a.lo <= a.hi
  requires: b.lo <= b.hi
  -- AEON verifies: intersection lo <= hi when ranges overlap
  let lo: Int = a.lo
  let hi: Int = a.hi
  return Range { lo: lo, hi: hi }
}

-- -----------------------------------------------------------------------
-- Matrix dimensions — shape safety
-- -----------------------------------------------------------------------

data Matrix {
  rows: Int
  cols: Int
}

pure matrixNew(rows: Int, cols: Int) -> Matrix {
  requires: rows > 0
  requires: cols > 0
  ensures:  result.rows == rows
  ensures:  result.cols == cols
  return Matrix { rows: rows, cols: cols }
}

pure matrixCanMultiply(a: Matrix, b: Matrix) -> Bool {
  ensures: result == (a.cols == b.rows)
  -- AEON verifies: matrix multiplication is only valid when
  -- inner dimensions match (a.cols == b.rows)
  return a.cols == b.rows
}

pure matrixTransposeDims(m: Matrix) -> Matrix {
  ensures: result.rows == m.cols
  ensures: result.cols == m.rows
  return Matrix { rows: m.cols, cols: m.rows }
}
