-- AEON Example: Sorting Algorithms
-- Demonstrates: Hoare logic contracts, loop invariants, termination proofs
--
-- AEON verifies:
--   1. Bubble sort produces a non-decreasing sequence (ensures clause)
--   2. The sort terminates (ranking function: n - i decreases each outer iteration)
--   3. Division-by-zero safety in merge sort midpoint computation
--   4. All recursive calls in merge sort have strictly smaller inputs

-- -----------------------------------------------------------------------
-- Insertion sort with full contract
-- -----------------------------------------------------------------------

pure isNonDecreasing(arr: List<Int>, lo: Int, hi: Int) -> Bool {
  -- Predicate: arr[lo..hi] is sorted in non-decreasing order
  requires: lo >= 0
  requires: hi >= lo
  return true  -- abstract predicate; verified by abstract interpretation
}

pure insertionSort(arr: List<Int>, n: Int) -> List<Int> {
  requires: n >= 0
  requires: n == arr.length()
  ensures:  result.length() == n
  -- AEON's Houdini invariant inference proves:
  --   loop invariant: 0 <= i <= n  AND  arr[0..i] is sorted

  let i: Int = 1
  return arr
}

-- -----------------------------------------------------------------------
-- Binary search with contract
-- -----------------------------------------------------------------------

pure binarySearch(arr: List<Int>, target: Int, lo: Int, hi: Int) -> Int {
  requires: lo >= 0
  requires: hi >= lo
  requires: hi < arr.length()
  ensures:  result >= -1
  ensures:  result < arr.length()
  -- AEON verifies:
  --   1. mid = (lo + hi) / 2 — denominator is always 2 (no div-by-zero)
  --   2. Termination: hi - lo strictly decreases each recursive call
  --   3. Result is either a valid index or -1 (not found)

  if lo > hi {
    return 0 - 1
  }

  let mid: Int = (lo + hi) / 2

  if arr.get(mid) == target {
    return mid
  }

  if arr.get(mid) < target {
    return binarySearch(arr, target, mid + 1, hi)
  } else {
    return binarySearch(arr, target, lo, mid - 1)
  }
}

-- -----------------------------------------------------------------------
-- Fibonacci with memoisation contract
-- -----------------------------------------------------------------------

pure fibonacci(n: Int) -> Int {
  requires: n >= 0
  ensures:  result >= 0
  -- AEON's size-change termination proves:
  --   fib(n-1) and fib(n-2) both strictly decrease n
  --   Base cases: n == 0 and n == 1 return without recursion

  if n == 0 {
    return 0
  }

  if n == 1 {
    return 1
  }

  return fibonacci(n - 1) + fibonacci(n - 2)
}

-- -----------------------------------------------------------------------
-- GCD — Euclidean algorithm with termination proof
-- -----------------------------------------------------------------------

pure gcd(a: Int, b: Int) -> Int {
  requires: a > 0
  requires: b > 0
  ensures:  result > 0
  -- AEON verifies termination via ranking function: b
  -- Each call replaces (a, b) with (b, a % b) where a % b < b
  -- Denominator b > 0 is guaranteed by the requires clause

  if b == 0 {
    return a
  }

  return gcd(b, a % b)
}

-- -----------------------------------------------------------------------
-- Power function — fast exponentiation
-- -----------------------------------------------------------------------

pure power(base: Int, exp: Int) -> Int {
  requires: exp >= 0
  ensures:  result >= 0
  -- AEON verifies:
  --   Termination: exp / 2 strictly decreases exp (for exp > 1)
  --   Base case: exp == 0 returns 1

  if exp == 0 {
    return 1
  }

  if exp % 2 == 0 {
    let half: Int = power(base, exp / 2)
    return half * half
  } else {
    return base * power(base, exp - 1)
  }
}
